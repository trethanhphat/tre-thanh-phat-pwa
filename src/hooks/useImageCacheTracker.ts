import { useEffect, useRef, useState } from 'react';
import { ensureNewsImageCachedByUrl } from '@/lib/news_images';
import { ensureProductImageCachedByUrl } from '@/lib/products_images';

/**
 * ‚úÖ Hook t·∫£i v√† cache ·∫£nh (t·ª± ƒë·ªông ph√¢n lu·ªìng theo lo·∫°i).
 *
 * @param imageUrls Danh s√°ch URL ·∫£nh
 * @param options.type 'news' | 'product' | 'generic'
 * @param options.skipPrefetch B·ªè qua prefetch
 */
export function useImageCacheTracker(
  imageUrls: string[],
  options?: { type?: 'news' | 'product' | 'generic'; skipPrefetch?: boolean }
) {
  const loadedRef = useRef<Set<string>>(new Set());
  const { type = 'generic', skipPrefetch = false } = options || {};

  // ‚úÖ L∆∞u cache URL (d·∫°ng blob ho·∫∑c URL g·ªëc)
  const [imageCache, setImageCache] = useState<Record<string, string>>({});

  /**
   * üîÅ H√†m thay to√†n b·ªô cache ·∫£nh (c√≥ th·ªÉ truy·ªÅn Record ho·∫∑c m·∫£ng {id,url})
   */
  const replaceImageCache = (next: Record<string, string> | { id: string; url: string }[]) => {
    // ‚öôÔ∏è D·ªçn blob c≈© ƒë·ªÉ tr√°nh memory leak
    Object.values(imageCache).forEach(url => {
      if (typeof url === 'string' && url.startsWith('blob:')) {
        URL.revokeObjectURL(url);
      }
    });

    // üîπ Cho ph√©p c·∫£ 2 ki·ªÉu input
    if (Array.isArray(next)) {
      const map = Object.fromEntries(next.map(n => [n.id, n.url]));
      setImageCache(map);
    } else {
      setImageCache(next);
    }
  };

  useEffect(() => {
    if (!imageUrls?.length || skipPrefetch) return;

    const imgs: HTMLImageElement[] = [];

    imageUrls.forEach(url => {
      if (!url || loadedRef.current.has(url)) return;

      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.loading = 'lazy';
      img.decoding = 'async';
      img.referrerPolicy = 'no-referrer';

      img.onload = async () => {
        try {
          if (type === 'news') {
            await ensureNewsImageCachedByUrl(url);
          } else if (type === 'product') {
            await ensureProductImageCachedByUrl(url);
          }
          console.log(`üíæ Cached ${type} image:`, url);
        } catch (err) {
          console.warn('‚ö†Ô∏è Cache error:', url, err);
        }
        loadedRef.current.add(url);
      };

      img.onerror = () => {
        console.warn(`‚ö†Ô∏è L·ªói t·∫£i ·∫£nh ${type}:`, url);
      };

      img.src = url;
      imgs.push(img);
    });

    // ‚úÖ D·ªçn listener khi unmount
    return () => {
      imgs.forEach(img => {
        img.onload = null;
        img.onerror = null;
      });
    };
  }, [imageUrls, type, skipPrefetch]);

  return { imageCache, replaceImageCache };
}
